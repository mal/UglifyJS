#! /usr/bin/env node
// -*- js -*-

// requires

global.sys = require(/^v0\.[012]/.test(process.version) ? "sys" : "util");

var fs = require("fs");
var uglify = require("../uglify-js"),
    con = uglify.consolidator,
    jsp = uglify.parser,
    pro = uglify.uglify;

// variables

var args = jsp.slice(process.argv, 2),
    comment = /^\/[\/\*]/,
    input = [],
    output = '-',
    options = {
        ascii: false,
        ast: false,
        beautify: false,
        consolidate: false,
        copyright: true,
        dead_code: true,
        definitions: {},
        hoist: false,
        indent: {
            level: 4,
            start: 0
        },
        inline: false,
        make: false,
        mangle: {
            functions: true,
            general: true,
            toplevel: false
        },
        overwrite: false,
        quote_keys: false,
        reserved: null,
        sequences: true,
        squeeze: true,
        strict: false,
        unsafe: false,
        verbose: false,
        wrap: 32 * 1024
    };

// functions

function copyright(code) {
    var result = '';
    if (options.copyright) {
        // clear any directives hoisted by a previous run
        code = code.replace(/^"[^"\n]+";\n/, '');
        // get comments from first token of a new tokenizer
        var comments = jsp.tokenizer(code)().comments_before;
        for (var i = 0, l = comments.length; i < l; i++) {
            var comment = comments[i];
            if (comment.type === 'comment1') {
                comment = '//' + comment.value + '\n';
            } else {
                comment = '/*' + comment.value + '*/';
            }
            result += comment;
        }
    }
    return result;
}

function define(arg, module) {
    function parse(val) {
        var ast, leaf;
        try {
            // use parser to decipher definitions
            ast = jsp.parse(val);
            // first node in toplevel
            leaf = ast[1][0];
            switch (leaf[0]) {
                case 'directive':
                    leaf[0] = 'string';
                    break;
                case 'stat':
                    leaf = leaf[1];
                    break;
            }
        } catch (err) {
            // failed to parse
        }
        // allow only literals for now, potential for dependency injection
        if (!leaf || !jsp.member(leaf[0], ['name', 'num', 'regexp', 'string'])) {
            // fallback to string when appropriate
            if (!module && !(/"/.test(val) && /'/.test(val))) {
                return [ 'string', val ];
            }
            throw "Expecting a literal, encountered: " + val;
        }
        return leaf;
    }
    function symbol(sym) {
        if (jsp.KEYWORDS_ATOM.hasOwnProperty(sym)) {
            throw "Don't define values for inbuilt constant '" + sym + "'";
        }
        return sym;
    }
    try {
        if (module) {
            var mod = require(arg);
            for (sym in mod) {
                if (mod.hasOwnProperty(sym)) {
                    // use sys.inspect to make mod[sym] parsable
                    options.definitions[sym] = parse(sys.inspect(mod[sym]));
                }
            }
        } else {
            if (arg.match(/^([a-z_\$][a-z_\$0-9]*)(?:=(.*))?$/i)) {
                var sym = symbol(RegExp.$1),
                    val = RegExp.$2 ? parse(RegExp.$2) : [ 'name', 'true' ];
                options.definitions[sym] = val;
            }
            else {
                throw "The --define option expects SYMBOL[=value]";
            }
        }
    } catch (err) {
        sys.print('ERROR: In option --define' + (module ? '-from-module' : '') + ' ' + arg + '\n');
        sys.print('ERROR: ' + err + '\n');
        process.exit(1);
    }
}

function read(input, callback) {
    var count = 0,
        content = [];
    // kick off async reads for all inputs
    input.forEach(function(path, i) {
        var code = '',
            stream = path === '-'
                   ? process.stdin
                   : fs.createReadStream(path, {
                         encoding: 'utf8'
                     });
        stream.on('data', function(chunk) {
            code += chunk;
        });
        stream.on('end', function() {
            content[i] = [ path, code ];
            if ( ++count === input.length ) {
                // all reads have completed
                callback(content);
            }
        });
        stream.resume();
    });
}

function squeeze(code) {
    var result = copyright(code);
    try {
        var ast = time('parse', function() {
            return jsp.parse(code);
        });
        if (options.strict) {
            // add directive to global scope for squeezing
            ast[1].unshift([ 'directive', 'use strict' ]);
        }
        if (options.consolidate) {
            ast = time('consolidate', function() {
                return con.ast_consolidate(ast);
            });
        }
        if (options.hoist) {
            ast = time('hoist', function() {
                return pro.ast_lift_variables(ast);
            });
        }
        if (options.mangle.general) {
            ast = time('mangle', function(){
                return pro.ast_mangle(ast, {
                    defines: options.definitions,
                    except: options.reserved,
                    no_functions: !options.mangle.functions,
                    toplevel: options.mangle.toplevel
                });
            });
        }
        if (options.squeeze) {
            ast = time('squeeze', function() {
                ast = pro.ast_squeeze(ast, {
                    dead_code: options.dead_code,
                    keep_comps: !options.unsafe,
                    make_seqs: options.sequences
                });
                if (options.unsafe) {
                    ast = pro.ast_squeeze_more(ast);
                }
                return ast;
            });
        }
        if (options.strict) {
            // remove the fake directive
            // this prevents duplicate global directives when combining multiple files
            // the global directive will be output only once; see output()
            ast[1].shift();
        }
        if (options.ast) {
            return sys.inspect(ast, null, null);
        }
        result += time('generate', function() {
            return pro.gen_code(ast, {
                ascii_only: options.ascii,
                beautify: options.beautify,
                indent_level: options.indent.level,
                indent_start: options.indent.start,
                inline_script: options.inline,
                quote_keys: options.quote_keys,
                space_colon: false
            });
        });
        if (options.wrap && !options.beautify) {
            result = time('split', function() {
                return pro.split_lines(result, options.wrap);
            });
        }
        return result;
    } catch (err) {
        sys.debug(err.stack);
        sys.debug(sys.inspect(err));
        sys.debug(JSON.stringify(err));
        process.exit(1);
    }
}

function time(name, cont) {
    if (!options.verbose) return cont();
    var start = new Date().getTime();
    try {
        return cont();
    } finally {
        sys.debug('// ' + name + ': ' + ((new Date().getTime() - start) / 1000).toFixed(3) + ' sec.');
    }
}

function write(output, code) {
    var stream = output === '-'
               ? process.stdout
               : fs.createWriteStream(output, {
                     encoding: 'utf8',
                     mode: 0644
                 });
    if (options.strict) {
        // when neccessary write in global directive with correct spacing
        var nl = options.beautify ? '\n\n' : comment.test(code) ? '\n' : '';
        stream.write('"use strict";' + nl);
    }
    stream.write(code.replace(/;*\s*$/, ''));
    if ( output !== '-' ) {
        stream.end();
    }
}

// main

while (args.length > 0) {
    var v = args.shift();
    switch (v) {
        case '--ascii':
            options.ascii = true;
            break;
        case '--ast':
            options.ast = true;
            break;
        case '-b':
        case '--beautify':
            options.beautify = true;
            break;
        case '-c':
        case '--consolidate-primitive-values':
            options.consolidate = true;
            break;
        case '-d':
        case '--define':
            define(args.shift());
            break;
        case '--define-from-module':
            define(args.shift(), true);
            break;
        case '-i':
        case '--indent':
            v = args.shift().split(',');
            options.indent.level = v[0];
            options.indent.start = v[1] || 0;
            break;
        case '--inline-script':
            options.inline = true;
            break;
        case '--lift-vars':
            options.hoist = true;
            break;
        case '--make':
            options.make = true;
            break;
        case '-mt':
        case '--mangle-toplevel':
            options.mangle.toplevel = true;
            break;
        case '--max-line-len':
            options.wrap = parseInt(args.shift(), 10);
            break;
        case '-nc':
        case '--no-copyright':
            options.copyright = false;
            break;
        case '--no-dead-code':
            options.dead_code = false;
            break;
        case '-nm':
        case '--no-mangle':
            options.mangle.general = false;
            break;
        case '-nmf':
        case '--no-mangle-functions':
            options.mangle.functions = false;
            break;
        case '--no-seqs':
            options.sequences = false;
            break;
        case '-ns':
        case '--no-squeeze':
            options.squeeze = false;
            break;
        case '-o':
        case '--output':
            output = args.shift();
            break;
        case '--overwrite':
            options.overwrite = true;
            break;
        case '-q':
        case '--quote-keys':
            options.quote_keys = true;
            break;
        case '--reserved-names':
            options.reserved = args.shift().split(',');
            break;
        case '-s':
        case '--strict':
            options.strict = true;
            break;
        case '--unsafe':
            options.unsafe = true;
            break;
        case '-v':
        case '--verbose':
            options.verbose = true;
            break;
        default:
            input.push(v);
    }
}

if (options.verbose) {
    pro.set_logger(function(msg){
        sys.debug(msg);
    });
}

jsp.set_logger(function(msg){
    sys.debug(msg);
});

if (options.make && input.length < 2) {
    var specification = input.length ? input[0] : 'Makefile.uglify.js';
    try {
        specification = JSON.parse(fs.readFileSync(specification, 'utf8'));
        input = specification.files.map(function(item) {
            return item.name;
        });
    } catch (err) {
        specification = undefined;
    }
}

if (!input.length) {
    input = ['-'];
}

read(input, function(content) {
    if (options.copyright || options.make || options.overwrite) {
        if (options.make && specification) {
            content = content.map(function(item, i) {
                var file = specification.files[i];
                if (file.module) {
                    item[1] = "!function(exports, global){global = this;\n" + item[1] + "\n;this." + file.module + " = exports;}({})";
                }
                else if (file.hide) {
                    item[1] = "(function(){" + item[1] + "}());";
                }
                return item;
            });
        }
        if (!options.overwrite) {
            // combine inputs that are not seperated by a leading comment for group squeezing
            content = content.reduce(function(arr, item) {
                var len = arr.length;
                if (len && !comment.test(item[1].trim())) {
                    arr[len-1][1] += '\n' + item[1];
                } else {
                    arr.push(item);
                }
                return arr;
            }, []);
        }
        content = content.map(function(item) {
            item[1] = squeeze(item[1]).trim();
            if (options.overwrite) {
                write(item[0], item[1]);
            }
            return item[1];
        });
        if (options.overwrite) return;
        write(output, content.join('\n'));
    } else {
        write(output, squeeze(content.reduce(function(code, item) {
            return code + item[1];
        }, '')));
    }
});
