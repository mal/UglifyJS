#! /usr/bin/env node
// -*- js -*-

// requires

global.sys = require(/^v0\.[012]/.test(process.version) ? "sys" : "util");

var fs = require("fs");
var uglify = require("../uglify-js"),
    con = uglify.consolidator,
    jsp = uglify.parser,
    pro = uglify.uglify;

// variables

var args = jsp.slice(process.argv, 2),
    input = [],
    output = '-',
    options = {
        ascii: false,
        ast: false,
        beautify: false,
        consolidate: false,
        copyright: true,
        dead_code: true,
        definitions: {},
        hoist: false,
        indent: {
            level: 4,
            start: 0
        },
        inline: false,
        make: false,
        mangle: {
            functions: true,
            general: true,
            toplevel: false
        },
        overwrite: false,
        quote_keys: false,
        reserved: null,
        sequences: true,
        squeeze: true,
        strict: false,
        unsafe: false,
        verbose: false,
        wrap: 32 * 1024
    };

// functions

function copyright(code) {
    var result = '';
    if (options.copyright) {
        var comments = jsp.tokenizer(code)().comments_before;
        for (var i = 0, l = comments.length; i < l; i++) {
            var comment = comments[i];
            if (comment.type === 'comment1') {
                comment = '//' + comment.value + '\n';
            } else {
                comment = '/*' + comment.value + '*/';
            }
            result += comment;
        }
    }
    return result;
}

function read(input, callback) {
    var count = 0,
        content = [];
    input.forEach(function(path, i) {
        var code = '',
            stream = path === '-'
                   ? process.stdin
                   : fs.createReadStream(path, {
                         encoding: 'utf8'
                     });
        stream.on('data', function(chunk) {
            code += chunk;
        });
        stream.on('end', function() {
            content[i] = [ path, code ];
            if ( ++count === input.length ) {
                callback(content);
            }
        });
        stream.resume();
    });
}

function squeeze(code) {
    var result = copyright(code);
    try {
        var ast = time('parse', function() {
            return jsp.parse(code);
        });
        if (options.strict) {
            ast[1].unshift([ 'directive', 'use strict' ]);
        }
        if (options.consolidate) {
            ast = time('consolidate', function() {
                return con.ast_consolidate(ast);
            });
        }
        if (options.hoist) {
            ast = time('hoist', function() {
                return pro.ast_lift_variables(ast);
            });
        }
        if (options.mangle.general) {
            ast = time('mangle', function(){
                return pro.ast_mangle(ast, {
                    defines: options.definitions,
                    except: options.reserved,
                    no_functions: !options.mangle.functions,
                    toplevel: options.mangle.toplevel
                });
            });
        }
        if (options.squeeze) {
            ast = time('squeeze', function() {
                ast = pro.ast_squeeze(ast, {
                    dead_code: options.dead_code,
                    keep_comps: !options.unsafe,
                    make_seqs: options.sequences
                });
                if (options.unsafe) {
                    ast = pro.ast_squeeze_more(ast);
                }
                return ast;
            });
        }
        if (options.strict) {
            ast[1].shift();
        }
        if (options.ast) {
            return sys.inspect(ast, null, null);
        }
        result += time('generate', function() {
            return pro.gen_code(ast, {
                ascii_only: options.ascii,
                beautify: options.beautify,
                indent_level: options.indent.level,
                indent_start: options.indent.start,
                inline_script: options.inline,
                quote_keys: options.quote_keys,
                space_colon: false
            });
        });
        if (options.wrap && !options.beautify) {
            result = time('split', function() {
                return pro.split_lines(result, options.wrap);
            });
        }
        return result;
    } catch (err) {
        sys.debug(err.stack);
        sys.debug(sys.inspect(err));
        sys.debug(JSON.stringify(err));
        process.exit(1);
    }
}

function time(name, cont) {
    if (!options.verbose) return cont();
    var start = new Date().getTime();
    try {
        return cont();
    } finally {
        sys.debug('// ' + name + ': ' + ((new Date().getTime() - start) / 1000).toFixed(3) + ' sec.');
    }
}

function write(output, code) {
    var stream = output === '-'
               ? process.stdout
               : fs.createWriteStream(output, {
                     encoding: 'utf8',
                     mode: 0644
                 });
    if (options.strict) {
        var nl = options.beautify ? '\n\n' : /^\/[\/\*]/.test(code) ? '\n' : '';
        stream.write('"use strict";' + nl);
    }
    stream.write(code.replace(/;*\s*$/, ''));
    if ( output !== '-' ) {
        stream.end();
    }
}

// main

while (args.length > 0) {
    var v = args.shift();
    switch (v) {
        case '--ascii':
            options.ascii = true;
            break;
        case '--ast':
            options.ast = true;
            break;
        case '-b':
        case '--beautify':
            options.beautify = true;
            break;
        case '-c':
        case '--consolidate-primitive-values':
            options.consolidate = true;
            break;
        case '-d':
        case '--define':
            read_definitions(args, options.definitions);
            break;
        case '--define-from-module':
            read_module_definitions(args, options.definitions);
            break;
        case '-i':
        case '--indent':
            v = args.shift().split(',');
            options.indent.level = v[0];
            options.indent.start = v[1] || 0;
            break;
        case '--inline-script':
            options.inline = true;
            break;
        case '--lift-vars':
            options.hoist = true;
            break;
        case '--make':
            options.make = true;
            break;
        case '-mt':
        case '--mangle-toplevel':
            options.mangle.toplevel = true;
            break;
        case '--max-line-len':
            options.wrap = parseInt(args.shift(), 10);
            break;
        case '-nc':
        case '--no-copyright':
            options.copyright = false;
            break;
        case '--no-dead-code':
            options.dead_code = false;
            break;
        case '-nm':
        case '--no-mangle':
            options.mangle.general = false;
            break;
        case '-nmf':
        case '--no-mangle-functions':
            options.mangle.functions = false;
            break;
        case '--no-seqs':
            options.sequences = false;
            break;
        case '-ns':
        case '--no-squeeze':
            options.squeeze = false;
            break;
        case '-o':
        case '--output':
            output = args.shift();
            break;
        case '--overwrite':
            options.overwrite = true;
            break;
        case '-q':
        case '--quote-keys':
            options.quote_keys = true;
            break;
        case '--reserved-names':
            options.reserved = args.shift().split(',');
            break;
        case '-s':
        case '--strict':
            options.strict = true;
            break;
        case '--unsafe':
            options.unsafe = true;
            break;
        case '-v':
        case '--verbose':
            options.verbose = true;
            break;
        default:
            input.push(v);
    }
}

if (options.verbose) {
    pro.set_logger(function(msg){
        sys.debug(msg);
    });
}

jsp.set_logger(function(msg){
    sys.debug(msg);
});

if (options.make && input.length < 2) {
    var specification = input.length ? input[0] : 'Makefile.uglify.js';
    try {
        specification = JSON.parse(fs.readFileSync(specification, 'utf8'));
        input = specification.files.map(function(item) {
            return item.name;
        });
    } catch (err) {
        specification = undefined;
    }
}

if (!input.length) {
    input = ['-'];
}

read(input, function(content) {
    if (options.copyright || options.make || options.overwrite) {
        if (options.make) {
            content = content.map(function(item, i) {
                var file = specification ? specification.files[i] : {};
                if (file.module) {
                    item[1] = "!function(exports, global){global = this;\n" + item[1] + "\n;this." + file.module + " = exports;}({})";
                }
                else if (file.hide) {
                    item[1] = "(function(){" + item[1] + "}());";
                }
                return item;
            });
        }
        content = content.map(function(item) {
            item[1] = squeeze(item[1]).trim();
            if (options.overwrite) {
                write(item[0], item[1]);
            }
            return item[1];
        });
        if (options.overwrite) return;
        write(output, content.join('\n'));
    } else {
        write(output, squeeze(content.reduce(function(code, item) {
            return code + item[1];
        }, '')));
    }
});
